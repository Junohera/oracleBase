/*
        
    DML(Data Management Language)
        데이터 조작 언어

        - INSERT
        - UPDATE
        - DELETE
        - SELECT
*/

-- [1] 샘플 테이블 생성
CREATE TABLE EXAM01 (
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(14)
);


-- [2] 레코드 추가
/*
    레코드 추가명령 사용1

        INSERT INTO ${TABLE_NAME} (
            FIELD1,
            FIELD2,
            FIELD3
        ) VALUES (
            VALUE1,
            VALUE2,
            VALUE3
        );

    필드명을 쓰는 란에는 NULLABLE이거나 기본값이 지정된 필드는 생략가능
    값은 문자와 숫자를 구분하여 입력(숫자: 123, 문자: 'ABC')

    레코드 추가명령 사용2

        INSERT INTO ${TABLE_NAME} VALUES (
            전체 COLUMN에 넣을 VALUE들...
        );


    첫번째 방식은 필드명과 입력값이 1:1 매핑
    두번째 방식은 필드순서대로 데이터 나열되어야 함.
*/

-- 필드명 1:1매핑
INSERT INTO EXAM01 (
    DEPTNO
    , DNAME
    , LOC
) VALUES (
    10
    , 'ACCOUNT'
    , 'NEW YORK'
);
-- 필드명 생략 모든 데이터 나열
INSERT INTO EXAM01 VALUES (30, 'SALES', 'CHICHAGO');
SELECT * FROM EXAM01;

-- null 값의 입력
-- 1) 필드명 안쓰는 경우
INSERT INTO EXAM01 VALUES (40, 'OPERATION', null);
-- 2) 필드명 쓰는 경우
INSERT INTO EXAM01(DEPTNO, DNAME) VALUES (20, 'MARKETING');
SELECT * FROM EXAM01;

-- 데이터 입력(INSERT)연습
-- BOOKLIST_SEQ라는 이름의 시퀀스를 만들고

-- 1번 형식
INSERT INTO BOOKLIST(BOOKNUM, SUBJECT, MAKEYEAR, INPRICE, OUTPRICE, GRADE) VALUES(BOOKLIST_SEQ.NEXTVAL, '좀비아이', 2020, 12000, 2500, '전체');

-- 2번 형식
INSERT INTO BOOKLIST VALUES (BOOKLIST_SEQ.NEXTVAL, '일곱해의 마지막', 2020, 12150, 2000, '전체');

-- 1번과 2번형식으로 각 다섯개(위의 예문 포함)의 레코드들을 추가하세요.

-- 시퀀스 생성
CREATE SEQUENCE BOOKLIST_SEQ START WITH 1 INCREMENT BY 1;
/* REF: 전체, 청소년구매가능, 성인전용 */
INSERT INTO BOOKLIST(BOOKNUM, SUBJECT, MAKEYEAR, INPRICE, OUTPRICE, GRADE) VALUES(BOOKLIST_SEQ.NEXTVAL, '그냥아이', 2020, 12000, 2500, '청소년구매가능');
INSERT INTO BOOKLIST(BOOKNUM, SUBJECT, MAKEYEAR, INPRICE, OUTPRICE, GRADE) VALUES(BOOKLIST_SEQ.NEXTVAL, '모든아이', 2012, 12000, 2500, '전체');
INSERT INTO BOOKLIST(BOOKNUM, SUBJECT, MAKEYEAR, INPRICE, OUTPRICE, GRADE) VALUES(BOOKLIST_SEQ.NEXTVAL, '몇몇아이', 2013, 12000, 2500, '전체');
INSERT INTO BOOKLIST(BOOKNUM, SUBJECT, MAKEYEAR, INPRICE, OUTPRICE, GRADE) VALUES(BOOKLIST_SEQ.NEXTVAL, '호크아이', 2013, 12000, 2500, '청소년구매가능');
INSERT INTO BOOKLIST(BOOKNUM, SUBJECT, MAKEYEAR, INPRICE, OUTPRICE, GRADE) VALUES(BOOKLIST_SEQ.NEXTVAL, '좀비아이', 2020, 12000, 2500, '성인전용');
INSERT INTO BOOKLIST VALUES(BOOKLIST_SEQ.NEXTVAL, '그냥아이', 2020, 12000, 2500, '청소년구매가능');
INSERT INTO BOOKLIST VALUES(BOOKLIST_SEQ.NEXTVAL, '모든아이', 2012, 12000, 2500, '전체');
INSERT INTO BOOKLIST VALUES(BOOKLIST_SEQ.NEXTVAL, '몇몇아이', 2013, 12000, 2500, '전체');
INSERT INTO BOOKLIST VALUES(BOOKLIST_SEQ.NEXTVAL, '호크아이', 2013, 12000, 2500, '청소년구매가능');
INSERT INTO BOOKLIST VALUES(BOOKLIST_SEQ.NEXTVAL, '좀비아이', 2020, 12000, 2500, '성인전용');

SELECT * FROM BOOKLIST;


/*
 * 	데이터 입력(INSERT) 연습
 * PERSON_SEQ를 만들고,
 * PERSON 테이블에 10명의 회원을 추가하세요.
 */

SELECT * FROM PERSON;

CREATE SEQUENCE PERSON_SEQ START WITH 1 INCREMENT BY 1;

SELECT * FROM COLS WHERE TABLE_NAME = 'PERSON';

INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성1', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성2', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성3', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성4', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성6', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성6', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성7', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성8', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성9', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');
INSERT INTO PERSON(PERSONNUM, PERSONNAME, PHONE, BIRTH, BPOINT, AGE, GENDER) VALUES (PERSON_SEQ.NEXTVAL, '박지성1', '010-9876-1234', TO_DATE('1994/11/10', 'yyyy/mm/dd'), 140, 29, 'M');

SELECT * FROM PERSON;

SELECT * FROM BOOKLIST;

-- 데이터 입력 연습 #3
DELETE FROM IN_OUT;
SELECT * FROM IN_OUT;
/* OUT_DATE, INDEXK, BOOKNUM, PERSONNUM, DISCOUNT */
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 1, 2, 2, 100);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 2, 3, 3, 200);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 3, 4, 4, 200);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 4, 6, 5, 300);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 5, 8, 6, 200);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 6, 9, 7, 200);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 7, 10, 8, 200);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 8, 11, 9, 100);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 9, 12, 10, 500);
INSERT INTO IN_OUT VALUES(TO_DATE('2020/06/25', 'yyyy/mm/dd'), 10, 13, 11, 500);

-- 데이터 변경 - 수정(UPDATE)
-- UPDATE 테이블명 SET 변경내용 WHERE 검색 조건

-- EXAM01 테이블에서 DEPTNO 값을 전부 30으로 변경
UPDATE EXAM01 SET DEPTNO = 30;
-- EXAM01 테이블에서 DNAME이 'ACCOUNT'인 행의 DEPTNO를 10으로 수정
UPDATE EXAM01 SET DEPTNO = 10 WHERE DNAME = 'ACCOUNT';
-- EXAM01 테이블에서 DNAME이 'SALES'인 행의 DEPTNO를 20으로 수정
UPDATE EXAM01 SET DEPTNO = 20 WHERE DNAME = 'SALES';

SELECT * FROM EXAM01;

-- UPDATE EX1
-- BOOKLIST테이블의 제목 '봉제인형 살인사건'도서의 GRADE를 '성인전용으로 '수정
UPDATE BOOKLIST SET GRADE = '성인전용' WHERE SUBJECT = '봉제인형 살인사건';
-- EMP테이블에서 SAL값이 3000이상인 사원의 급여 10%삭감
UPDATE EMP SET SAL = SAL - (SAL * 0.1) WHERE SAL >= 3000;
-- HIREDATE가 2002년 이전인 사원의 급여를 + 2000 -> (2001-12-13보다 작거나 같은)
UPDATE EMP SET SAL = SAL + 2000 WHERE HIREDATE <= '2001-12-31';
-- ENAME이 J로 시작하는 사원의 JOB을 MANAGER로 변경
UPDATE EMP SET JOB = 'MANAGER' WHERE ENAME LIKE 'j%' OR ENAME LIKE 'J%';
-- PERSON테이블에서 BPOINT가 200이 넘는 사람만 BPOINT*100으로 변경
UPDATE PERSON SET BPOINT = BPOINT*100 WHERE BPOINT >= 200;
-- IN_OUT TABLE에서 할인금액이 100이 넘으면 모두 할인금액을 90으로 변경
UPDATE IN_OUT SET DISCOUNT = 90 WHERE DISCOUNT > 100;


-- 레코드의 삭제
-- DELETE FROM 테이블명 
-- IN_OUT테이블에서 DISCOUNT가 100이하인 레코드를 삭제
DELETE FROM IN_OUT WHERE DISCOUNT < 100;

-- 삭제의 제한
DELETE FROM BOOKLIST WHERE SUBJECT = '봉제인형 살인사건';

/*
    해당 도서가 대여내역(IN_OUT)에 존재하고 대여내역의 도서번호가 BOOKLIST의 도서번로를
    참조하는 외래키가 설정되어 있다면 BOOKLIST의 해당 도서는 삭제될 수 없습니다.
    도서가 지워지는 순간 IN_OUT의 외래키 규칙에 위배되므로 삭제되는 것 자체가 불가능하게 됩니다.
    삭제하려면 참조하고 있는 외래키의 옵션을 도서가 삭제되면 대여내역도 함께 삭제되는 옵션으로 변경해야 합니다.
*/

-- 외래키의 참조값 동시삭제를 위한 옵션 수정
SELECT * FROM ALL_CONSTRAINTS WHERE TABLE_NAME = 'IN_OUT';
ALTER TABLE IN_OUT DROP CONSTRAINT FK1;

-- 새로운 외래키 추가
ALTER TABLE IN_OUT ADD CONSTRAINT FK1 FOREIGN KEY(BOOKNUM) REFERENCES BOOKLIST(BOOKNUM) ON DELETE CASCADE;
-- ON DELETE CASCADE : BOOKLIST의 도서가 삭제되면 IN_OUT의 해당도서 대여내역도 함께 삭제하는 옵션
DELETE FROM BOOKLIST WHERE SUBJECT = '봉제인형 살인사건';
SELECT * FROM BOOKLIST;
SELECT * FROM IN_OUT;

-- PERSON 테이블에서 회원 한명을 삭제하면, IN_OUT테이블에서도 해당회원이 대여한 기록을 같이 삭제하도록
-- 외래키설정을 바꾸시오.(외래키 제약조건 삭제후 재생성)
ALTER TABLE IN_OUT DROP CONSTRAINT FK2;
ALTER TABLE IN_OUT ADD CONSTRAINT FK2 FOREIGN KEY(PERSONNUM) REFERENCES PERSON(PERSONNUM) ON DELETE CASCADE;
DELETE FROM PERSON WHERE PERSONNAME = '홍길동';
SELECT * FROM PERSON;
SELECT * FROM IN_OUT;